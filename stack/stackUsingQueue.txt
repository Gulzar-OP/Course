ğŸ”¸ Approach 1: Stack using 2 Queues
âš™ï¸ Logic:
q1 â†’ main queue

q2 â†’ temporary queue used during push operation

ğŸ‘‰ push(x):
Sabse pehle x ko q2 mein daalo.

Fir q1 ke saare elements q2 mein daal do.

Swap q1 aur q2. Ab q1 ke front mein hamesha latest element hoga â†’ just like top of stack.

ğŸ‘‰ pop():
Simply q1.pop() â†’ jo top tha, wahi front hai.

ğŸ‘‰ top():
Return q1.front().

ğŸ‘‰ empty():
Return q1.empty().

ğŸ“Œ Example Dry Run:
cpp
Copy
Edit
Stack s;
s.push(10);   // q1 = [10]
s.push(20);   // q2 = [20], q1 = [10] â†’ q2 = [20, 10] â†’ swap â†’ q1 = [20, 10]
s.push(30);   // q2 = [30], q1 = [20,10] â†’ q2 = [30,20,10] â†’ swap â†’ q1 = [30,20,10]
So, top = 30

âœ… Code (2 Queues):
cpp
Copy
Edit
void push(int x) {
    q2.push(x);
    while (!q1.empty()) {
        q2.push(q1.front());
        q1.pop();
    }
    swap(q1, q2);
}
   
   ==============================================================================

   ğŸ”¸ Approach 2: Stack using 1 Queue
âš™ï¸ Logic:
Sirf ek queue chahiye.

Jab bhi push(x) karo:

x ko queue mein push karo.

Queue ke size - 1 elements ko baar baar pop + push karo (rotate) â†’ taaki x front pe aa jaaye.

ğŸ‘‰ push(x):
queue.push(x)

size = q.size()

Loop size-1 times:

pop front

push back

ğŸ‘‰ pop():
Just q.pop() â†’ latest element hai front pe.

ğŸ‘‰ top():
q.front()

ğŸ“Œ Example Dry Run:
cpp
Copy
Edit
push(1) â†’ q = [1]
push(2) â†’ q = [2,1]
push(3) â†’ q = [3,2,1]
So front of queue = 3 = top of stack âœ…

âœ… Code (1 Queue):
cpp
Copy
Edit
void push(int x) {
    q.push(x);
    int size = q.size();
    for (int i = 0; i < size - 1; i++) {
        q.push(q.front());
        q.pop();
    }
}
âœ… Summary Table:
Operation	2 Queues	1 Queue
Push	        O(n)	  O(n)
Pop	            O(1)	  O(1)
Top         	O(1)	  O(1)
Space       	More	  Less